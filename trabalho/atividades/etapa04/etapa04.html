<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Etapa 04 || CV - 2025.2</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="etapa04.css" />
    <link rel="stylesheet" href="../../../menu.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"
      integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA=="
      crossorigin="anonymous"
    />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Dancing+Script:wght@700&display=swap"
    />
    <!-- Slick CSS no <head> -->
    <link
      rel="stylesheet"
      type="text/css"
      href="https://cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="https://cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick-theme.css"
    />

    <link
      href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@500&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@500&display=swap"
      rel="stylesheet"
    />
  </head>

  <!-- JQuery + Slick JS -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.min.js"></script>

  <!-- Arquivo JS externo -->
  <script src="etapa04.js"></script>

  <body>
    <div class="container">
      <nav>
        <ul class="mcd-menu">
          <!-- <li>
                    <a href="">
                        <i class="fa fa-home"></i>
                        <div>
                            <strong>Home</strong>
                            <small>Incompleto</small>
                        </div>
                    </a>
                </li> -->
          <li>
            <a href="../../../index.html">
              <i class="fa fa-edit"></i>
              <div>
                <strong>Sobre n√≥s</strong>
                <small>Completo</small>
              </div>
            </a>
          </li>
          <li>
            <a href="../../../aulas/aulas.html">
              <i class="fa fa-archive"></i>
              <div>
                <strong>Aulas</strong>
                <small>Incompleto</small>
              </div>
            </a>
          </li>
          <li>
            <a href="../../trabalho.html" class="active">
              <i class="fa fa-archive"></i>
              <div>
                <strong>Projeto</strong>
                <small>Incompleto</small>
              </div>
            </a>
          </li>
        </ul>
      </nav>
    </div>

    <div class="principal">
      <h1 class="titulo">
        Etapa 4: Desenvolvimento do Sistema de Processamento da Vis√£o (SPV)
      </h1>
      <!-- <br>
        <div class = "about-btns">
            <button 
                onclick="document.location='lab2.html'" type = "button" 
                class = "btn btn-pink">Fotos e V√≠deos</button>
        </div>
        <br> -->
      <div class="integrantes-list">
        <div class="integrante-card">
          <span class="integrante-nome">Lucas Sanchez Bitencourt</span>
          <span class="integrante-ra">RA 11201921617</span>
        </div>
        <div class="integrante-card">
          <span class="integrante-nome">Marcela Ceschim Caburl√£o</span>
          <span class="integrante-ra">RA 11201920483</span>
        </div>
        <div class="integrante-card">
          <span class="integrante-nome">Michael Franklin Saito</span>
          <span class="integrante-ra">RA 11201810988</span>
        </div>
        <div class="integrante-card">
          <span class="integrante-nome">Data do documento:</span>
          <span class="integrante-ra">28/07/2025</span>
        </div>
      </div>

      <br />
      <h2>Ecossistema de Programas Utilizados</h2>
        
        <br>
        <button class="btn-codigo" onclick="abrirPopup('popup3')">üü® calibrador_de_cor.py</button><br>
        <p>Fun√ß√£o: Permite ajustar os valores HSV interativamente com barras deslizantes (trackbars) para definir intervalos de cor.</p>
        <p>üõ†Ô∏è Componentes principais:</p>
        <ul>
            <li>Trackbars com cv2.createTrackbar()</li>
            <li>M√°scara de cor ao vivo</li>
            <li>Visualiza√ß√£o ao lado da imagem original</li>
        </ul>
        <p>üîç Uso: Testar e encontrar valores ideais para segmenta√ß√£o de cores.</p>

        <br>
        <br>
        <button class="btn-codigo" onclick="abrirPopup('popup2')">üü© calibrador_camera.py</button><br>
        <p>Fun√ß√£o: Realiza a calibra√ß√£o da c√¢mera usando um tabuleiro xadrez (chessboard), gerando a matriz de calibra√ß√£o e distor√ß√£o.</p>
        <p>üõ†Ô∏è Componentes principais:</p>
        <ul>
            <li>Detecta cantos no padr√£o xadrez</li>
            <li>Usa cv2.calibrateCamera()</li>
            <li>Salva os dados em calibracao_camera.npz</li>
        </ul>
        <p>üì¶ Sa√≠da: Arquivo .npz com mtx e dist.</p>

        <br>
        <br>
        <button class="btn-codigo" onclick="abrirPopup('popup5')">üìò calibracao_camera.npz (explica√ß√£o)</button><br>
        <p>Tipo: Arquivo de dados (n√£o √© um script execut√°vel)</p>
        <p>Fun√ß√£o: Cont√©m os par√¢metros de calibra√ß√£o da c√¢mera gerados pelo calibrador_camera.py.</p>
        <p>üîç Inclui:</p>
        <ul>
            <li>mtx: matriz intr√≠nseca da c√¢mera</li>
            <li>dist: coeficientes de distor√ß√£o da lente</li>
        </ul>
        <p>üß† Uso: Corrigir distor√ß√µes em imagens capturadas pela c√¢mera real.</p>

        <br>
        <br>
        <button class="btn-codigo" onclick="abrirPopup('popup1')">üü¶ id_cor.py</button><br>
        <p>Fun√ß√£o: Detecta a cor predominante de um objeto sob a c√¢mera e fala o nome da cor com √°udio.</p>
        <p>üõ†Ô∏è Componentes principais:</p>
        <ul>
            <li>Captura de v√≠deo com OpenCV</li>
            <li>Convers√£o para HSV</li>
            <li>Leitura de cor na √°rea central da imagem</li>
            <li>Bot√£o para acionar a leitura</li>
            <li>Voz com pyttsx3</li>
        </ul>
        <p>üë§ Uso t√≠pico: Assist√™ncia visual para pessoas com defici√™ncia visual.</p>
    
        <br>
        <br>
        <h2>C√≥digo Extra</h2>
        <br>
        <button class="btn-codigo" onclick="abrirPopup('popup4')">üü• meu_detector.py</button><br>
        <p>Fun√ß√£o: Detecta objetos de uma determinada cor na imagem e desenha contornos e r√≥tulos.</p>
        <p>üõ†Ô∏è Componentes principais:</p>
        <ul>
            <li>Leitura de imagem ou webcam</li>
            <li>M√°scara com HSV</li>
            <li>Detec√ß√£o de contornos com cv2.findContours()</li>
            <li>Desenha o contorno e nomeia a cor</li>
        </ul>
        <p>üìå Uso comum: Reconhecimento visual de objetos coloridos em tempo real.</p>

        <br>
        <br>
        <h2>Checklist de Conformidade</h2>
        <br>
        <ul>
          <li>Nosso sistema utiliza extensivamente a API OpenCV, com fun√ß√µes como cv2.VideoCapture, cv2.undistort, 
            cv2.inRange e cv2.findContours para todo o processamento visual.</li>
          <li>O c√≥digo foi desenvolvido em Python 3 com bibliotecas padr√£o, garantindo a compatibilidade com o ambiente Ubuntu-Linux.</li>
          <li>Al√©m do OpenCV, utilizamos a biblioteca pyttsx3 para a funcionalidade de fala.</li>
        </ul>
        

        

      <!-- POPUPS -->

  <div id="popup1" class="overlay">
    <div class="popup">
      <button class="fechar" onclick="fecharPopup('popup1')">Fechar</button>
      <h3>id_cor.py</h3>
      <pre>

# ==============================================================================
# ESZA019 ‚Äì Vis√£o Computacional
#
# Lucas Sanchez Bitencourt - RA 11201921617
# Marcela Ceschim Caburlao - RA 11201920483
# Michael Franklin Saito da Silva - RA 11201810988
#
# ==============================================================================
# Programa: Identifica√ß√£o de cor, com bot√£o
# Descri√ß√£o: Verifica a cor dentro de uma regi√£o determinada no programa;
#            regi√£o circular no centro da tela
# ==============================================================================

import cv2  # Biblioteca para processamento de imagem e acesso √† webcam
import numpy as np  # Biblioteca para opera√ß√µes num√©ricas com arrays
import pyttsx3  # Biblioteca para convers√£o de texto em fala
import tkinter as tk  # Biblioteca para cria√ß√£o de interfaces gr√°ficas
from PIL import Image, ImageTk  # Para converter imagens do OpenCV para Tkinter
import threading  # Biblioteca para execu√ß√£o de tarefas em paralelo (threads)

# Inicializa a engine de voz
voz = pyttsx3.init()
voz.setProperty('rate', 150)  # Define a velocidade da fala

# Fun√ß√£o para identificar o nome da cor com base nos valores HSV
def nome_da_cor(h, s, v):
    if s < 40 and v > 200:
        return "branco"  # Baixa satura√ß√£o e alto brilho ‚Üí branco
    elif v < 40:
        return "preto"  # Baixo brilho ‚Üí preto
    elif h < 15 or h > 165:
        return "vermelho"
    elif 15 <= h < 35:
        return "amarelo"
    elif 35 <= h < 85:
        return "verde"
    elif 86 <= h < 135:
        return "azul"
    elif 135 <= h < 160:
        return "roxo"
    elif 161 <= h <= 169:
        return "rosa"
    return "indefinido"  # Caso n√£o se encaixe em nenhuma faixa

# Fun√ß√£o que pronuncia o nome da cor atual usando uma thread para n√£o travar a interface
def falar_cor():
    global cor_atual
    if cor_atual and cor_atual != "indefinido":
        # Cria uma thread para executar a fala sem bloquear o restante do programa
        threading.Thread(target=lambda: voz.say(f"A cor √© {cor_atual}") or voz.runAndWait()).start()

# Fun√ß√£o que atualiza a imagem da webcam na interface gr√°fica
def atualizar_video():
    global cor_atual
    ret, frame = cap.read()  # Captura um frame da c√¢mera
    if not ret:
        return  # Se n√£o capturou corretamente, retorna

    frame = cv2.flip(frame, 1)  # Espelha a imagem horizontalmente
    altura, largura, _ = frame.shape  # Obt√©m dimens√µes da imagem
    cx, cy = largura // 2, altura // 2  # Calcula o centro da imagem

    # Define a regi√£o de interesse (ROI) central de 20x20 pixels
    roi = frame[cy-10:cy+10, cx-10:cx+10]
    hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)  # Converte ROI para o espa√ßo de cor HSV
    h, s, v = hsv[10, 10]  # Pega os valores HSV do pixel central da ROI
    cor_atual = nome_da_cor(h, s, v)  # Identifica a cor

    # Desenha um c√≠rculo ao redor da ROI
    cv2.circle(frame, (cx, cy), 10, (255, 255, 255), 2)
    # Escreve o nome da cor na tela
    cv2.putText(frame, cor_atual, (cx + 20, cy), cv2.FONT_HERSHEY_SIMPLEX, 1, (255,255,255), 2)

    # Converte a imagem BGR do OpenCV para RGB e depois para formato ImageTk
    img_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
    img_pil = Image.fromarray(img_rgb)
    img_tk = ImageTk.PhotoImage(image=img_pil)
    video_label.imgtk = img_tk  # Mant√©m refer√™ncia da imagem
    video_label.configure(image=img_tk)  # Atualiza o widget com a nova imagem

    # Chama novamente essa fun√ß√£o ap√≥s 20 milissegundos (loop de atualiza√ß√£o da c√¢mera)
    janela.after(20, atualizar_video)

# Inicia a captura da webcam (dispositivo 0 padr√£o)
cap = cv2.VideoCapture(0)
cor_atual = ""  # Vari√°vel global que armazena a cor atual detectada

# Cria a janela principal da interface
janela = tk.Tk()
janela.title("Detector de Cor")

# Widget para exibir o v√≠deo
video_label = tk.Label(janela)
video_label.pack()

# Bot√£o que chama a fun√ß√£o para falar a cor
botao = tk.Button(janela, text="Falar Cor", font=("Arial", 16), command=falar_cor, bg="lightblue")
botao.pack(pady=10)

# Inicia a atualiza√ß√£o do v√≠deo
atualizar_video()

# Inicia o loop principal da interface gr√°fica
janela.mainloop()

# Libera a c√¢mera ap√≥s o fechamento da janela
cap.release()


      </pre>
    </div>
  </div>

  <div id="popup2" class="overlay">
    <div class="popup">
      <button class="fechar" onclick="fecharPopup('popup2')">Fechar</button>
      <h3>calibrador_camera.py</h3>
      <pre>

# ==============================================================================
# ESZA019 ‚Äì Vis√£o Computacional
#
# Lucas Sanchez Bitencourt - RA 11201921617
# Marcela Ceschim Caburlao - RA 11201920483
# Michael Franklin Saito da Silva - RA 11201810988
#
# ==============================================================================
# Programa: Calibrador de C√¢mera com Tabuleiro de Xadrez
# Descri√ß√£o: Captura imagens de um tabuleiro, calcula os par√¢metros
#            da c√¢mera e os salva em um arquivo.
# ==============================================================================

import cv2  # Biblioteca de vis√£o computacional
import numpy as np  # Biblioteca para opera√ß√µes com arrays e matrizes
import glob  # Biblioteca para lidar com arquivos e diret√≥rios
import os  # Biblioteca para manipula√ß√£o do sistema de arquivos

# --- CONFIGURA√á√ïES DO TABULEIRO ---
# Define o n√∫mero de cantos internos do tabuleiro de xadrez (colunas, linhas)
CHECKERBOARD = (8, 6)
TAMANHO_ARQUIVO_CALIBRACAO = "calibracao_camera.npz"  # Nome do arquivo onde os par√¢metros ser√£o salvos
# -----------------------------------

# Crit√©rios de parada para o algoritmo de refinamento dos cantos
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)

# Cria√ß√£o da matriz de pontos 3D reais no espa√ßo (0,0,0), (1,0,0), (2,0,0), ..., (7,5,0)
objp = np.zeros((CHECKERBOARD[0] * CHECKERBOARD[1], 3), np.float32)
objp[:, :2] = np.mgrid[0:CHECKERBOARD[0], 0:CHECKERBOARD[1]].T.reshape(-1, 2)

# Listas para armazenar os pontos do objeto 3D e seus correspondentes 2D nas imagens
objpoints = []  # Coordenadas 3D no mundo real
imgpoints = []  # Coordenadas 2D nas imagens capturadas

# Inicializa a c√¢mera
captura = cv2.VideoCapture(0)

# Instru√ß√µes ao usu√°rio
print("\n--- Calibrador de Camera ---")
print("1. Mostre o tabuleiro de xadrez para a camera de varios angulos.")
print("2. Pressione a BARRA DE ESPACO para capturar uma imagem valida.")
print("3. Capture pelo menos 15 imagens para uma boa calibracao.")
print("4. Pressione a tecla 'c' para calibrar e salvar.")
print("5. Pressione a tecla 'q' para sair.")

# Contador de imagens v√°lidas capturadas
imagens_capturadas = 0

# Loop principal
while True:
    ret, quadro = captura.read()  # Captura um quadro da webcam
    if not ret:
        break  # Encerra o loop se a captura falhar
    
    quadro_cinza = cv2.cvtColor(quadro, cv2.COLOR_BGR2GRAY)  # Converte o quadro para escala de cinza
    
    # Tenta encontrar os cantos do tabuleiro de xadrez na imagem
    ret_corners, corners = cv2.findChessboardCorners(quadro_cinza, CHECKERBOARD, None)
    
    # Mostra o n√∫mero de imagens capturadas no v√≠deo
    texto_info = f"Imagens capturadas: {imagens_capturadas}"
    cv2.putText(quadro, texto_info, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)

    # Se encontrou os cantos, desenha-os na imagem para feedback visual
    if ret_corners:
        cv2.drawChessboardCorners(quadro, CHECKERBOARD, corners, ret_corners)

    # Exibe a imagem na janela chamada 'Calibracao'
    cv2.imshow('Calibracao', quadro)
    
    # L√™ a tecla pressionada
    tecla = cv2.waitKey(1) & 0xFF

    # Sai do programa se a tecla 'q' for pressionada
    if tecla == ord('q'):
        break
    # Captura uma imagem se a barra de espa√ßo for pressionada
    elif tecla == ord(' '):
        if ret_corners:
            # Refina as coordenadas dos cantos detectados para maior precis√£o
            corners2 = cv2.cornerSubPix(quadro_cinza, corners, (11, 11), (-1, -1), criteria)
            objpoints.append(objp)  # Adiciona os pontos 3D do objeto
            imgpoints.append(corners2)  # Adiciona os pontos 2D da imagem
            imagens_capturadas += 1
            print(f"Imagem {imagens_capturadas} capturada com sucesso!")
        else:
            print("Nenhum tabuleiro encontrado. Tente um angulo diferente.")
    # Realiza a calibra√ß√£o se a tecla 'c' for pressionada
    elif tecla == ord('c'):
        if imagens_capturadas > 10:
            print("\nRealizando a calibracao... Por favor, aguarde.")
            # Executa a calibra√ß√£o da c√¢mera com os pontos coletados
            ret_calib, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(
                objpoints, imgpoints, quadro_cinza.shape[::-1], None, None)
            
            if ret_calib:
                print("Calibracao bem-sucedida!")
                # Salva os par√¢metros da calibra√ß√£o em um arquivo .npz
                np.savez(TAMANHO_ARQUIVO_CALIBRACAO, mtx=mtx, dist=dist)
                print(f"Arquivo '{TAMANHO_ARQUIVO_CALIBRACAO}' salvo!")
                break
            else:
                print("A calibracao falhou. Tente capturar mais imagens.")
        else:
            print("Capture pelo menos 10-15 imagens antes de calibrar.")

# Libera a c√¢mera e fecha todas as janelas
captura.release()
cv2.destroyAllWindows()

      </pre>
    </div>
  </div>

  <div id="popup3" class="overlay">
    <div class="popup">
      <button class="fechar" onclick="fecharPopup('popup3')">Fechar</button>
      <h3>calibrador_de_cor.py</h3>
      <pre>

# ==============================================================================
# ESZA019 ‚Äì Vis√£o Computacional
#
# Lucas Sanchez Bitencourt - RA 11201921617
# Marcela Ceschim Caburlao - RA 11201920483
# Michael Franklin Saito da Silva - RA 11201810988
#
# ==============================================================================
# Programa: Calibrador de cores HSV
# Descri√ß√£o: Calibra a camera para detectar cores apresentadas
#            para a camera, necess√°rio utilizar o mouse
# ==============================================================================

import cv2  # Biblioteca para vis√£o computacional
import numpy as np  # Biblioteca para opera√ß√µes num√©ricas com arrays

# Fun√ß√£o dummy usada para criar os trackbars (n√£o faz nada ao ser chamada)
def funcao_vazia(x):
    pass

# --- NOVA FUN√á√ÉO PARA O MOUSE ---
# Callback para detectar clique do mouse na janela da c√¢mera
def detectar_clique(event, x, y, flags, param):
    if event == cv2.EVENT_LBUTTONDOWN:  # Se o bot√£o esquerdo for pressionado
        quadro_hsv = param  # Recebe o quadro HSV da c√¢mera como par√¢metro
        pixel_hsv = quadro_hsv[y, x]  # Pega os valores HSV do ponto clicado
        h, s, v = pixel_hsv[0], pixel_hsv[1], pixel_hsv[2]
        
        print(f"\nValores HSV do ponto clicado:")
        print(f"H: {h}, S: {s}, V: {v}")
        
        # Ajusta automaticamente os sliders com base no valor clicado (com margens)
        cv2.setTrackbarPos("H_min", "Trackbars", max(0, h - 10))
        cv2.setTrackbarPos("H_max", "Trackbars", min(179, h + 10))
        cv2.setTrackbarPos("S_min", "Trackbars", max(0, s - 40))
        cv2.setTrackbarPos("S_max", "Trackbars", min(255, s + 40))
        cv2.setTrackbarPos("V_min", "Trackbars", max(0, v - 40))
        cv2.setTrackbarPos("V_max", "Trackbars", min(255, v + 40))

# Inicializa a c√¢mera (dispositivo padr√£o 0)
captura = cv2.VideoCapture(0)

# Cria janelas para os sliders e para visualiza√ß√£o da c√¢mera
cv2.namedWindow("Trackbars")
cv2.resizeWindow("Trackbars", 600, 300)
cv2.namedWindow("Camera")  # Janela principal da c√¢mera para callback

# Cria√ß√£o dos sliders (trackbars) para ajustar os limites HSV
cv2.createTrackbar("H_min", "Trackbars", 0, 179, funcao_vazia)
cv2.createTrackbar("H_max", "Trackbars", 179, 179, funcao_vazia)
cv2.createTrackbar("S_min", "Trackbars", 0, 255, funcao_vazia)
cv2.createTrackbar("S_max", "Trackbars", 255, 255, funcao_vazia)
cv2.createTrackbar("V_min", "Trackbars", 0, 255, funcao_vazia)
cv2.createTrackbar("V_max", "Trackbars", 255, 255, funcao_vazia)

# Instru√ß√µes no terminal
print("\nFerramenta de Calibracao de Cor HSV (v2.0)")
print("-----------------------------------------")
print("-> Clique com o botao esquerdo do mouse sobre uma cor na janela 'Camera'.")
print("-> Os sliders serao ajustados automaticamente para valores proximos.")
print("-> Faca o ajuste fino ate a mascara ficar perfeita.")
print("-> Pressione 's' para salvar e sair, ou 'q' para sair.")

# Loop principal
while True:
    ret, quadro = captura.read()  # L√™ um frame da c√¢mera
    if not ret: break  # Se n√£o conseguiu ler, termina
    
    quadro = cv2.flip(quadro, 1)  # Espelha o frame horizontalmente
    quadro_hsv = cv2.cvtColor(quadro, cv2.COLOR_BGR2HSV)  # Converte para HSV

    # Ativa o detector de clique do mouse passando o frame HSV
    cv2.setMouseCallback("Camera", detectar_clique, quadro_hsv)

    # L√™ os valores atuais dos sliders
    h_min, h_max, s_min, s_max, v_min, v_max = (
        cv2.getTrackbarPos("H_min", "Trackbars"),
        cv2.getTrackbarPos("H_max", "Trackbars"),
        cv2.getTrackbarPos("S_min", "Trackbars"),
        cv2.getTrackbarPos("S_max", "Trackbars"),
        cv2.getTrackbarPos("V_min", "Trackbars"),
        cv2.getTrackbarPos("V_max", "Trackbars"),
    )

    # Cria os limites HSV a partir dos sliders
    limite_inferior = np.array([h_min, s_min, v_min])
    limite_superior = np.array([h_max, s_max, v_max])

    # Cria uma m√°scara bin√°ria com base nos limites selecionados
    mascara = cv2.inRange(quadro_hsv, limite_inferior, limite_superior)

    # Mostra as janelas da c√¢mera e da m√°scara
    cv2.imshow("Camera", quadro)
    cv2.imshow("Mascara", mascara)

    tecla = cv2.waitKey(1)
    if tecla & 0xFF == ord('q'): break  # Sai ao pressionar 'q'
    if tecla & 0xFF == ord('s'):
        # Ao pressionar 's', imprime os valores HSV ajustados para copiar no c√≥digo
        print(f'\nValores salvos! Copie a linha abaixo para o seu dicionario:')
        print(f'"nome_da_sua_cor": ([{h_min}, {s_min}, {v_min}], [{h_max}, {s_max}, {v_max}])')
        break

# Libera a c√¢mera e fecha todas as janelas
captura.release()
cv2.destroyAllWindows()

      </pre>
    </div>
  </div>

  <div id="popup4" class="overlay">
    <div class="popup">
      <button class="fechar" onclick="fecharPopup('popup4')">Fechar</button>
      <h3>meu_detector.py</h3>
      <pre>

# ==============================================================================
# ESZA019 ‚Äì Vis√£o Computacional
#
# Lucas Sanchez Bitencourt - RA 11201921617
# Marcela Ceschim Caburlao - RA 11201920483
# Michael Franklin Saito da Silva - RA 11201810988
#
# ==============================================================================
# Programa: Detector de 'objeto'
# Descri√ß√£o: Detecta formas e cores de objetos a frente da camera.
# ==============================================================================

import cv2  # Biblioteca de vis√£o computacional
import numpy as np  # Biblioteca para opera√ß√µes com arrays
import pyttsx3  # Biblioteca de convers√£o texto-para-fala

# --- 1. CARREGAR OS DADOS DE CALIBRA√á√ÉO ---
try:
    with np.load('calibracao_camera.npz') as data:
        mtx = data['mtx']  # Matriz intr√≠nseca da c√¢mera
        dist = data['dist']  # Vetor de distor√ß√£o
    print("Arquivo de calibracao carregado com sucesso!")
except FileNotFoundError:
    print("ERRO: Arquivo de calibracao 'calibracao_camera.npz' nao encontrado.")
    print("Por favor, execute o programa 'calibrador_camera.py' primeiro.")
    mtx, dist = None, None  # Define como None caso n√£o encontre
# ---------------------------------------------

# --- INICIALIZA√á√ÉO DO MOTOR DE FALA ---
engine = pyttsx3.init()
engine.setProperty('rate', 150)  # Velocidade da fala
# ------------------------------------

# --- 2. CONFIGURA√á√ïES E VARI√ÅVEIS GLOBAIS ---
NOME_JANELA = "Detector Interativo - NOME DA EQUIPE"
texto_global_detectado = ""  # Guarda o √∫ltimo objeto detectado para fala

# Define a posi√ß√£o do bot√£o "Falar" na tela
botao_pos_inicial = (20, 400)
botao_pos_final = (220, 450)
# ---------------------------------------------

# Dicion√°rio com os limites HSV de cada cor
CORES_HSV = {
    "vermelho": ([165, 129, 161], [179, 209, 241]),
    "azul": ([97, 164, 120], [117, 244, 200]),
    "verde": ([50, 70, 118], [70, 150, 198]),
    # ... outras cores podem ser adicionadas
}

# Fun√ß√£o para identificar o tipo de forma com base nos v√©rtices
def identificar_forma(contorno):
    perimetro = cv2.arcLength(contorno, True)
    aproximacao = cv2.approxPolyDP(contorno, 0.04 * perimetro, True)  # Aproxima o contorno
    num_vertices = len(aproximacao)
    forma = "Nao identificado"
    if num_vertices == 3:
        forma = "Triangulo"
    elif num_vertices == 4:
        (x, y, largura, altura) = cv2.boundingRect(aproximacao)
        proporcao = float(largura) / altura
        if 0.95 <= proporcao <= 1.05:
            forma = "Quadrado"
        else:
            forma = "Retangulo"
    elif num_vertices > 4:
        forma = "Circulo"
    return forma

# --- 3. FUN√á√ÉO QUE LIDA COM O CLIQUE DO MOUSE ---
def acao_clique_botao(event, x, y, flags, param):
    global texto_global_detectado
    if event == cv2.EVENT_LBUTTONDOWN:
        # Verifica se o clique est√° dentro da √°rea do bot√£o
        if botao_pos_inicial[0] < x < botao_pos_final[0] and botao_pos_inicial[1] < y < botao_pos_final[1]:
            print("Botao 'Falar' pressionado!")
            if texto_global_detectado != "":
                print(f"Falando: {texto_global_detectado}")
                engine.say(texto_global_detectado)
                engine.runAndWait()
            else:
                print("Nenhum objeto detectado para falar.")

# --- IN√çCIO DO PROGRAMA PRINCIPAL ---
captura = cv2.VideoCapture(0)  # Inicia a webcam

# --- 4. REGISTRA A FUN√á√ÉO DO MOUSE ---
cv2.namedWindow(NOME_JANELA)
cv2.setMouseCallback(NOME_JANELA, acao_clique_botao)
# -------------------------------------

while True:
    ret, quadro = captura.read()  # Captura o frame da c√¢mera
    if not ret:
        break

    # --- 5. APLICA A CORRE√á√ÉO DE DISTOR√á√ÉO, SE DISPON√çVEL ---
    if mtx is not None and dist is not None:
        quadro = cv2.undistort(quadro, mtx, dist, None, mtx)
    # --------------------------------------------------------

    quadro = cv2.flip(quadro, 1)  # Espelha a imagem na horizontal
    quadro_hsv = cv2.cvtColor(quadro, cv2.COLOR_BGR2HSV)  # Converte para HSV

    objetos_encontrados = []  # Lista para armazenar objetos detectados
    texto_global_detectado = ""  # Limpa o texto global a cada frame

    # Loop por cada cor configurada
    for nome_cor, (limite_inferior, limite_superior) in CORES_HSV.items():
        # Cria m√°scara para a cor atual
        mascara = cv2.inRange(quadro_hsv, np.array(limite_inferior), np.array(limite_superior))
        
        # Caso especial: vermelho pode cruzar o limite de 0¬∫ na escala HSV
        if nome_cor == "vermelho2":
            mascara_vermelho1 = cv2.inRange(quadro_hsv, np.array(CORES_HSV["vermelho"][0]), np.array(CORES_HSV["vermelho"][1]))
            mascara = cv2.add(mascara_vermelho1, mascara)
            nome_cor = "vermelho"

        # Encontra os contornos dos objetos da m√°scara
        contornos, _ = cv2.findContours(mascara, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        for contorno in contornos:
            if cv2.contourArea(contorno) > 500:  # Filtra pequenos ru√≠dos
                objetos_encontrados.append((cv2.contourArea(contorno), contorno, nome_cor))

    # Se pelo menos um objeto foi detectado
    if len(objetos_encontrados) > 0:
        # Seleciona o maior objeto
        area_maior, contorno_maior, cor_detectada = max(objetos_encontrados, key=lambda item: item[0])
        forma_detectada = identificar_forma(contorno_maior)

        # --- 6. ATUALIZA O TEXTO GLOBAL COM A FORMA E COR ---
        texto_global_detectado = f"{forma_detectada} {cor_detectada}"

        # Desenha um ret√¢ngulo ao redor do objeto e escreve a classifica√ß√£o
        (x, y, largura, altura) = cv2.boundingRect(contorno_maior)
        cv2.rectangle(quadro, (x, y), (x + largura, y + altura), (0, 255, 0), 2)
        cv2.putText(quadro, texto_global_detectado.capitalize(), (x, y - 10),
                    cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)

    # --- 7. DESENHA O BOT√ÉO DE "FALAR" ---
    cv2.rectangle(quadro, botao_pos_inicial, botao_pos_final, (200, 200, 200), -1)  # Fundo do bot√£o
    cv2.putText(quadro, "Falar", (botao_pos_inicial[0] + 50, botao_pos_inicial[1] + 35),
                cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 0), 2)
    # ---------------------------------------

    # Exibe o quadro na janela
    cv2.imshow(NOME_JANELA, quadro)

    # Sai do programa se a tecla 'q' for pressionada
    tecla = cv2.waitKey(1) & 0xFF
    if tecla == ord('q'):
        break

# Libera a c√¢mera e fecha todas as janelas
captura.release()
cv2.destroyAllWindows()

      </pre>
    </div>
  </div>

  <div id="popup5" class="overlay">
    <div class="popup">
      <button class="fechar" onclick="fecharPopup('popup5')">Fechar</button>
      <h3>calibracao_camera.npz</h3>
      <pre>

        "Arquivo gerado pelo c√≥digo - 'calibrador_camera.py'"
        
      </pre>
    </div>
  </div>


          
    </div>
  </body>
</html>
