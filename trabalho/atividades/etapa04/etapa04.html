<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>Etapa 04 || CV - 2025.2</title>
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="etapa04.css" />
    <link rel="stylesheet" href="../../../menu.css" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"
      integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA=="
      crossorigin="anonymous"
    />
    <link rel="preconnect" href="https://fonts.gstatic.com" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Dancing+Script:wght@700&display=swap"
    />
    <!-- Slick CSS no <head> -->
    <link
      rel="stylesheet"
      type="text/css"
      href="https://cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.css"
    />
    <link
      rel="stylesheet"
      type="text/css"
      href="https://cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick-theme.css"
    />

    <link
      href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@500&display=swap"
      rel="stylesheet"
    />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@500&display=swap"
      rel="stylesheet"
    />
  </head>

  <!-- JQuery + Slick JS -->
  <script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.min.js"></script>

  <!-- Arquivo JS externo -->
  <script src="etapa04.js"></script>

  <body>
    <div class="container">
      <nav>
        <ul class="mcd-menu">
          <!-- <li>
                    <a href="">
                        <i class="fa fa-home"></i>
                        <div>
                            <strong>Home</strong>
                            <small>Incompleto</small>
                        </div>
                    </a>
                </li> -->
          <li>
            <a href="../../../index.html">
              <i class="fa fa-edit"></i>
              <div>
                <strong>Sobre n√≥s</strong>
                <small>Completo</small>
              </div>
            </a>
          </li>
          <li>
            <a href="../../../aulas/aulas.html">
              <i class="fa fa-archive"></i>
              <div>
                <strong>Aulas</strong>
                <small>Incompleto</small>
              </div>
            </a>
          </li>
          <li>
            <a href="../../trabalho.html" class="active">
              <i class="fa fa-archive"></i>
              <div>
                <strong>Projeto</strong>
                <small>Incompleto</small>
              </div>
            </a>
          </li>
        </ul>
      </nav>
    </div>

    <div class="principal">
      <h1 class="titulo">
        Etapa 4: Desenvolvimento do Sistema de Processamento da Vis√£o (SPV)
      </h1>
      <!-- <br>
        <div class = "about-btns">
            <button 
                onclick="document.location='lab2.html'" type = "button" 
                class = "btn btn-pink">Fotos e V√≠deos</button>
        </div>
        <br> -->
      <div class="integrantes-list">
        <div class="integrante-card">
          <span class="integrante-nome">Lucas Sanchez Bitencourt</span>
          <span class="integrante-ra">RA 11201921617</span>
        </div>
        <div class="integrante-card">
          <span class="integrante-nome">Marcela Ceschim Caburl√£o</span>
          <span class="integrante-ra">RA 11201920483</span>
        </div>
        <div class="integrante-card">
          <span class="integrante-nome">Michael Franklin Saito</span>
          <span class="integrante-ra">RA 11201810988</span>
        </div>
        <div class="integrante-card">
          <span class="integrante-nome">Data do documento:</span>
          <span class="integrante-ra">28/07/2025</span>
        </div>
      </div>

      <br />
      <h2>Ecossistema de Programas Utilizados</h2>
        
        <br>
        <button class="btn-codigo" onclick="abrirPopup('popup3')">üü® calibrador_de_cor.py</button><br>
        <p>Fun√ß√£o: Permite ajustar os valores HSV interativamente com barras deslizantes (trackbars) para definir intervalos de cor.</p>
        <p>üõ†Ô∏è Componentes principais:</p>
        <ul>
            <li>Trackbars com cv2.createTrackbar()</li>
            <li>M√°scara de cor ao vivo</li>
            <li>Visualiza√ß√£o ao lado da imagem original</li>
        </ul>
        <p>üîç Uso: Testar e encontrar valores ideais para segmenta√ß√£o de cores.</p>

        <br>
        <br>
        <button class="btn-codigo" onclick="abrirPopup('popup2')">üü© calibrador_camera.py</button><br>
        <p>Fun√ß√£o: Realiza a calibra√ß√£o da c√¢mera usando um tabuleiro xadrez (chessboard), gerando a matriz de calibra√ß√£o e distor√ß√£o.</p>
        <p>üõ†Ô∏è Componentes principais:</p>
        <ul>
            <li>Detecta cantos no padr√£o xadrez</li>
            <li>Usa cv2.calibrateCamera()</li>
            <li>Salva os dados em calibracao_camera.npz</li>
        </ul>
        <p>üì¶ Sa√≠da: Arquivo .npz com mtx e dist.</p>

        <br>
        <br>
        <button class="btn-codigo" onclick="abrirPopup('popup5')">üìò calibracao_camera.npz (explica√ß√£o)</button><br>
        <p>Tipo: Arquivo de dados (n√£o √© um script execut√°vel)</p>
        <p>Fun√ß√£o: Cont√©m os par√¢metros de calibra√ß√£o da c√¢mera gerados pelo calibrador_camera.py.</p>
        <p>üîç Inclui:</p>
        <ul>
            <li>mtx: matriz intr√≠nseca da c√¢mera</li>
            <li>dist: coeficientes de distor√ß√£o da lente</li>
        </ul>
        <p>üß† Uso: Corrigir distor√ß√µes em imagens capturadas pela c√¢mera real.</p>

        <br>
        <br>
        <button class="btn-codigo" onclick="abrirPopup('popup1')">üü¶ id_cor.py</button><br>
        <p>Fun√ß√£o: Detecta a cor predominante de um objeto sob a c√¢mera e fala o nome da cor com √°udio.</p>
        <p>üõ†Ô∏è Componentes principais:</p>
        <ul>
            <li>Captura de v√≠deo com OpenCV</li>
            <li>Convers√£o para HSV</li>
            <li>Leitura de cor na √°rea central da imagem</li>
            <li>Bot√£o para acionar a leitura</li>
            <li>Voz com pyttsx3</li>
        </ul>
        <p>üë§ Uso t√≠pico: Assist√™ncia visual para pessoas com defici√™ncia visual.</p>
    
        <br>
        <br>
        <h2>C√≥digo Extra</h2>
        <br>
        <button class="btn-codigo" onclick="abrirPopup('popup4')">üü• meu_detector.py</button><br>
        <p>Fun√ß√£o: Detecta objetos de uma determinada cor na imagem e desenha contornos e r√≥tulos.</p>
        <p>üõ†Ô∏è Componentes principais:</p>
        <ul>
            <li>Leitura de imagem ou webcam</li>
            <li>M√°scara com HSV</li>
            <li>Detec√ß√£o de contornos com cv2.findContours()</li>
            <li>Desenha o contorno e nomeia a cor</li>
        </ul>
        <p>üìå Uso comum: Reconhecimento visual de objetos coloridos em tempo real.</p>

        <br>
        <br>
        <h2>Checklist de Conformidade</h2>
        <br>
        <ul>
          <li>Nosso sistema utiliza extensivamente a API OpenCV, com fun√ß√µes como cv2.VideoCapture, cv2.undistort, 
            cv2.inRange e cv2.findContours para todo o processamento visual.</li>
          <li>O c√≥digo foi desenvolvido em Python 3 com bibliotecas padr√£o, garantindo a compatibilidade com o ambiente Ubuntu-Linux.</li>
          <li>Al√©m do OpenCV, utilizamos a biblioteca pyttsx3 para a funcionalidade de fala.</li>
        </ul>
        

        

      <!-- POPUPS -->

  <div id="popup1" class="overlay">
    <div class="popup">
      <button class="fechar" onclick="fecharPopup('popup1')">Fechar</button>
      <h3>id_cor.py</h3>
      <pre>
        # ==============================================================================
        # ESZA019 ‚Äì Vis√£o Computacional
        #
        # Lucas Sanchez Bitencourt - RA 11201921617
        # Marcela Ceschim Caburlao - RA 11201920483
        # Michael Franklin Saito da Silva - RA 11201810988
        #
        # ==============================================================================
        # Programa: Identifica√ß√£o de cor, com bot√£o
        # Descri√ß√£o: Verifica a cor dentro de uma regi√£o determinada no programa;
        #            regi√£o circular no centro da tela
        # ==============================================================================
        import cv2
        import numpy as np
        import pyttsx3
        import tkinter as tk
        from PIL import Image, ImageTk
        import threading

        # Inicializa a engine de voz
        voz = pyttsx3.init()
        voz.setProperty('rate', 150)

        # Fun√ß√£o para identificar o nome da cor
        def nome_da_cor(h, s, v):
            if s < 40 and v > 200:
                return "branco"
            elif v < 40:
                return "preto"
            elif h < 15 or h > 165:
                return "vermelho"
            elif 15 <= h < 35:
                return "amarelo"
            elif 35 <= h < 85:
                return "verde"
            elif 86 <= h < 135:
                return "azul"
            elif 135 <= h < 160:
                return "roxo"
            elif 161 <= h <= 169:
                return "rosa"
            return "indefinido"

        # Fun√ß√£o que fala a cor atual
        def falar_cor():
            global cor_atual
            if cor_atual and cor_atual != "indefinido":
                threading.Thread(target=lambda: voz.say(f"A cor √© {cor_atual}") or voz.runAndWait()).start()

        # Atualiza a imagem da webcam
        def atualizar_video():
            global cor_atual
            ret, frame = cap.read()
            if not ret:
                return

            frame = cv2.flip(frame, 1)
            altura, largura, _ = frame.shape
            cx, cy = largura // 2, altura // 2

            # Regi√£o para an√°lise
            roi = frame[cy-10:cy+10, cx-10:cx+10]
            hsv = cv2.cvtColor(roi, cv2.COLOR_BGR2HSV)
            h, s, v = hsv[10, 10]
            cor_atual = nome_da_cor(h, s, v)

            # Desenha c√≠rculo e nome da cor
            cv2.circle(frame, (cx, cy), 10, (255, 255, 255), 2)
            cv2.putText(frame, cor_atual, (cx + 20, cy), cv2.FONT_HERSHEY_SIMPLEX, 1, (255,255,255), 2)

            # Converte para ImageTk e mostra no label
            img_rgb = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
            img_pil = Image.fromarray(img_rgb)
            img_tk = ImageTk.PhotoImage(image=img_pil)
            video_label.imgtk = img_tk
            video_label.configure(image=img_tk)

            # Repetir ap√≥s 20 ms
            janela.after(20, atualizar_video)

        # Inicia a c√¢mera
        cap = cv2.VideoCapture(0)
        cor_atual = ""

        # Interface Tkinter
        janela = tk.Tk()
        janela.title("Detector de Cor com Bot√£o")

        video_label = tk.Label(janela)
        video_label.pack()

        botao = tk.Button(janela, text="Falar Cor", font=("Arial", 16), command=falar_cor, bg="lightblue")
        botao.pack(pady=10)

        # Come√ßa o loop de v√≠deo
        atualizar_video()
        janela.mainloop()

        cap.release()

      </pre>
    </div>
  </div>

  <div id="popup2" class="overlay">
    <div class="popup">
      <button class="fechar" onclick="fecharPopup('popup2')">Fechar</button>
      <h3>calibrador_camera.py</h3>
      <pre>
        # ==============================================================================
        # ESZA019 ‚Äì Vis√£o Computacional
        #
        # Lucas Sanchez Bitencourt - RA 11201921617
        # Marcela Ceschim Caburlao - RA 11201920483
        # Michael Franklin Saito da Silva - RA 11201810988
        #
        # ==============================================================================
        # Programa: Calibrador de C√¢mera com Tabuleiro de Xadrez
        # Descri√ß√£o: Captura imagens de um tabuleiro, calcula os par√¢metros
        #            da c√¢mera e os salva em um arquivo.
        # ==============================================================================
        import cv2
        import numpy as np
        import glob
        import os

        # --- CONFIGURA√á√ïES DO TABULEIRO ---
        # Altere estes valores para o n√∫mero de cantos INTERNOS do seu tabuleiro.
        # Por exemplo, um tabuleiro 8x11 tem 7x10 cantos internos.
        CHECKERBOARD = (8, 6) 
        TAMANHO_ARQUIVO_CALIBRACAO = "calibracao_camera.npz"
        # -----------------------------------

        # Crit√©rio para o refinamento dos cantos
        criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)

        # Preparar os "pontos do objeto", que s√£o as coordenadas 3D ideais do tabuleiro.
        # (0,0,0), (1,0,0), (2,0,0) ..., (6,9,0)
        objp = np.zeros((CHECKERBOARD[0] * CHECKERBOARD[1], 3), np.float32)
        objp[:, :2] = np.mgrid[0:CHECKERBOARD[0], 0:CHECKERBOARD[1]].T.reshape(-1, 2)

        # Arrays para guardar os pontos do objeto e os pontos da imagem de todas as imagens.
        objpoints = [] # Pontos no mundo 3D
        imgpoints = [] # Pontos na imagem 2D

        captura = cv2.VideoCapture(0)

        print("\n--- Calibrador de Camera ---")
        print("1. Mostre o tabuleiro de xadrez para a camera de varios angulos.")
        print("2. Pressione a BARRA DE ESPACO para capturar uma imagem valida.")
        print("3. Capture pelo menos 15 imagens para uma boa calibracao.")
        print("4. Pressione a tecla 'c' para calibrar e salvar.")
        print("5. Pressione a tecla 'q' para sair.")

        imagens_capturadas = 0

        while True:
            ret, quadro = captura.read()
            if not ret:
                break
            
            quadro_cinza = cv2.cvtColor(quadro, cv2.COLOR_BGR2GRAY)
            
            # Encontra os cantos do tabuleiro
            ret_corners, corners = cv2.findChessboardCorners(quadro_cinza, CHECKERBOARD, None)
            
            # Desenha informa√ß√µes na tela
            texto_info = f"Imagens capturadas: {imagens_capturadas}"
            cv2.putText(quadro, texto_info, (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 1, (0, 255, 0), 2)

            # Se os cantos forem encontrados, desenha-os para dar feedback visual
            if ret_corners:
                cv2.drawChessboardCorners(quadro, CHECKERBOARD, corners, ret_corners)

            cv2.imshow('Calibracao', quadro)
            
            tecla = cv2.waitKey(1) & 0xFF

            if tecla == ord('q'):
                break
            elif tecla == ord(' '): # Captura com a barra de espa√ßo
                if ret_corners:
                    # Refina a posi√ß√£o dos cantos para maior precis√£o
                    corners2 = cv2.cornerSubPix(quadro_cinza, corners, (11, 11), (-1, -1), criteria)
                    objpoints.append(objp)
                    imgpoints.append(corners2)
                    imagens_capturadas += 1
                    print(f"Imagem {imagens_capturadas} capturada com sucesso!")
                else:
                    print("Nenhum tabuleiro encontrado. Tente um angulo diferente.")
            elif tecla == ord('c'):
                if imagens_capturadas > 10:
                    print("\nRealizando a calibracao... Por favor, aguarde.")
                    # Realiza a calibra√ß√£o
                    ret_calib, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, quadro_cinza.shape[::-1], None, None)
                    
                    if ret_calib:
                        print("Calibracao bem-sucedida!")
                        # Salva os par√¢metros em um arquivo
                        np.savez(TAMANHO_ARQUIVO_CALIBRACAO, mtx=mtx, dist=dist)
                        print(f"Arquivo '{TAMANHO_ARQUIVO_CALIBRACAO}' salvo!")
                        break
                    else:
                        print("A calibracao falhou. Tente capturar mais imagens.")
                else:
                    print("Capture pelo menos 10-15 imagens antes de calibrar.")

        captura.release()
        cv2.destroyAllWindows()
      </pre>
    </div>
  </div>

  <div id="popup3" class="overlay">
    <div class="popup">
      <button class="fechar" onclick="fecharPopup('popup3')">Fechar</button>
      <h3>calibrador_de_cor.py</h3>
      <pre>
        # ==============================================================================
        # ESZA019 ‚Äì Vis√£o Computacional
        #
        # Lucas Sanchez Bitencourt - RA 11201921617
        # Marcela Ceschim Caburlao - RA 11201920483
        # Michael Franklin Saito da Silva - RA 11201810988
        #
        # ==============================================================================
        # Programa: Calibrador de cores HSV
        # Descri√ß√£o: Calibra a camera para detectar cores apresentadas
        #            para a camera, necess√°rio utilizar o mouse
        # ==============================================================================
        import cv2
        import numpy as np

        def funcao_vazia(x):
            pass

        # --- FUN√á√ÉO PARA O MOUSE, SELECIONAR E VERIFICAR ---
        def detectar_clique(event, x, y, flags, param):
            if event == cv2.EVENT_LBUTTONDOWN: # Se o bot√£o esquerdo do mouse for pressionado
                # Pega o quadro HSV que passamos como par√¢metro
                quadro_hsv = param
                # Pega o valor HSV do pixel (y, x)
                pixel_hsv = quadro_hsv[y, x]
                h, s, v = pixel_hsv[0], pixel_hsv[1], pixel_hsv[2]
                
                print(f"\nValores HSV do ponto clicado:")
                print(f"H: {h}, S: {s}, V: {v}")
                
                # Sugest√£o: Atualizar os trackbars para valores pr√≥ximos ao clicado
                # Isso facilita o ajuste fino.
                cv2.setTrackbarPos("H_min", "Trackbars", max(0, h - 10))
                cv2.setTrackbarPos("H_max", "Trackbars", min(179, h + 10))
                cv2.setTrackbarPos("S_min", "Trackbars", max(0, s - 40))
                cv2.setTrackbarPos("S_max", "Trackbars", min(255, s + 40))
                cv2.setTrackbarPos("V_min", "Trackbars", max(0, v - 40))
                cv2.setTrackbarPos("V_max", "Trackbars", min(255, v + 40))

        captura = cv2.VideoCapture(0)

        cv2.namedWindow("Trackbars")
        cv2.resizeWindow("Trackbars", 600, 300)
        cv2.namedWindow("Camera") # Nomeia a janela da c√¢mera para o callback

        # Cria os trackbars...
        cv2.createTrackbar("H_min", "Trackbars", 0, 179, funcao_vazia)
        cv2.createTrackbar("H_max", "Trackbars", 179, 179, funcao_vazia)
        cv2.createTrackbar("S_min", "Trackbars", 0, 255, funcao_vazia)
        cv2.createTrackbar("S_max", "Trackbars", 255, 255, funcao_vazia)
        cv2.createTrackbar("V_min", "Trackbars", 0, 255, funcao_vazia)
        cv2.createTrackbar("V_max", "Trackbars", 255, 255, funcao_vazia)

        print("\nFerramenta de Calibracao de Cor HSV (v2.0)")
        print("-----------------------------------------")
        print("-> Clique com o botao esquerdo do mouse sobre uma cor na janela 'Camera'.")
        print("-> Os sliders serao ajustados automaticamente para valores proximos.")
        print("-> Faca o ajuste fino ate a mascara ficar perfeita.")
        print("-> Pressione 's' para salvar e sair, ou 'q' para sair.")

        while True:
            ret, quadro = captura.read()
            if not ret: break
            
            quadro = cv2.flip(quadro, 1)
            quadro_hsv = cv2.cvtColor(quadro, cv2.COLOR_BGR2HSV)
            
            # --- ATIVA O DETECTOR DE CLIQUE ---
            # Passamos 'quadro_hsv' como par√¢metro para a fun√ß√£o de callback
            cv2.setMouseCallback("Camera", detectar_clique, quadro_hsv)

            h_min, h_max, s_min, s_max, v_min, v_max = (
                cv2.getTrackbarPos("H_min", "Trackbars"),
                cv2.getTrackbarPos("H_max", "Trackbars"),
                cv2.getTrackbarPos("S_min", "Trackbars"),
                cv2.getTrackbarPos("S_max", "Trackbars"),
                cv2.getTrackbarPos("V_min", "Trackbars"),
                cv2.getTrackbarPos("V_max", "Trackbars"),
            )
            
            limite_inferior = np.array([h_min, s_min, v_min])
            limite_superior = np.array([h_max, s_max, v_max])
            
            mascara = cv2.inRange(quadro_hsv, limite_inferior, limite_superior)
            
            cv2.imshow("Camera", quadro)
            cv2.imshow("Mascara", mascara)
            
            tecla = cv2.waitKey(1)
            if tecla & 0xFF == ord('q'): break
            if tecla & 0xFF == ord('s'):
                print(f'\nValores salvos! Copie a linha abaixo para o seu dicionario:')
                print(f'"nome_da_sua_cor": ([{h_min}, {s_min}, {v_min}], [{h_max}, {s_max}, {v_max}])')
                break

        captura.release()
        cv2.destroyAllWindows()
      </pre>
    </div>
  </div>

  <div id="popup4" class="overlay">
    <div class="popup">
      <button class="fechar" onclick="fecharPopup('popup4')">Fechar</button>
      <h3>meu_detector.py</h3>
      <pre>
        # ==============================================================================
        # ESZA019 ‚Äì Vis√£o Computacional
        #
        # Lucas Sanchez Bitencourt - RA 11201921617
        # Marcela Ceschim Caburlao - RA 11201920483
        # Michael Franklin Saito da Silva - RA 11201810988
        #
        # ==============================================================================
        # Programa: Detector de 'objeto'
        # Descri√ß√£o: Detecta formas e cores de objetos a frente da camera.
        #            
        # ==============================================================================
        import cv2
        import numpy as np
        import pyttsx3

        # --- 1. CARREGAR OS DADOS DE CALIBRA√á√ÉO ---
        try:
            with np.load('calibracao_camera.npz') as data:
                mtx = data['mtx']
                dist = data['dist']
            print("Arquivo de calibracao carregado com sucesso!")
        except FileNotFoundError:
            print("ERRO: Arquivo de calibracao 'calibracao_camera.npz' nao encontrado.")
            print("Por favor, execute o programa 'calibrador_camera.py' primeiro.")
            mtx, dist = None, None
        # ---------------------------------------------


        # --- INICIALIZA√á√ÉO DO MOTOR DE FALA ---
        engine = pyttsx3.init()
        engine.setProperty('rate', 150)
        # ------------------------------------

        # --- 1. CONFIGURA√á√ïES E VARI√ÅVEIS GLOBAIS ---
        NOME_JANELA = "Detector Interativo - NOME DA EQUIPE"
        texto_global_detectado = "" # Guarda o √∫ltimo texto detectado para a fun√ß√£o do mouse usar

        # Define a √°rea do nosso bot√£o
        botao_pos_inicial = (20, 400)
        botao_pos_final = (220, 450)
        # ---------------------------------------------

        CORES_HSV = {
            "vermelho": ([165, 129, 161], [179, 209, 241]),
            "azul": ([97, 164, 120], [117, 244, 200]),
            "verde": ([50, 70, 118], [70, 150, 198]),
            # ... (suas outras cores aqui)
        }

        def identificar_forma(contorno):
            perimetro = cv2.arcLength(contorno, True)
            aproximacao = cv2.approxPolyDP(contorno, 0.04 * perimetro, True)
            num_vertices = len(aproximacao)
            forma = "Nao identificado"
            if num_vertices == 3: forma = "Triangulo"
            elif num_vertices == 4:
                (x, y, largura, altura) = cv2.boundingRect(aproximacao)
                proporcao = float(largura) / altura
                if 0.95 <= proporcao <= 1.05: forma = "Quadrado"
                else: forma = "Retangulo"
            elif num_vertices > 4: forma = "Circulo"
            return forma

        # --- 2. FUN√á√ÉO QUE LIDA COM O CLIQUE DO MOUSE ---
        def acao_clique_botao(event, x, y, flags, param):
            global texto_global_detectado
            # Se o bot√£o esquerdo do mouse for pressionado
            if event == cv2.EVENT_LBUTTONDOWN:
                # Verifica se as coordenadas (x, y) do clique est√£o dentro da √°rea do bot√£o
                if botao_pos_inicial[0] < x < botao_pos_final[0] and botao_pos_inicial[1] < y < botao_pos_final[1]:
                    print("Botao 'Falar' pressionado!")
                    if texto_global_detectado != "":
                        print(f"Falando: {texto_global_detectado}")
                        engine.say(texto_global_detectado)
                        engine.runAndWait()
                    else:
                        print("Nenhum objeto detectado para falar.")

        # --- IN√çCIO DO PROGRAMA PRINCIPAL ---
        captura = cv2.VideoCapture(0)
        # --- 3. REGISTRAR A FUN√á√ÉO DO MOUSE NA NOSSA JANELA ---
        cv2.namedWindow(NOME_JANELA)
        cv2.setMouseCallback(NOME_JANELA, acao_clique_botao)
        # ----------------------------------------------------

        while True:
            ret, quadro = captura.read()
            if not ret: break

            # --- 2. APLICAR A CORRE√á√ÉO DE DISTOR√á√ÉO ---
            if mtx is not None and dist is not None:
                quadro = cv2.undistort(quadro, mtx, dist, None, mtx)
            # -------------------------------------------

            quadro = cv2.flip(quadro, 1) # Espelhar a imagem j√° corrigida
            quadro_hsv = cv2.cvtColor(quadro, cv2.COLOR_BGR2HSV)
            
            objetos_encontrados = []
            
            # Resetar o texto se nenhum objeto for encontrado nesta rodada
            texto_global_detectado = ""

            for nome_cor, (limite_inferior, limite_superior) in CORES_HSV.items():
                # ... (c√≥digo de detec√ß√£o de cor continua o mesmo) ...
                mascara = cv2.inRange(quadro_hsv, np.array(limite_inferior), np.array(limite_superior))
                if nome_cor == "vermelho2":
                    mascara_vermelho1 = cv2.inRange(quadro_hsv, np.array(CORES_HSV["vermelho"][0]), np.array(CORES_HSV["vermelho"][1]))
                    mascara = cv2.add(mascara_vermelho1, mascara)
                    nome_cor = "vermelho"
                contornos, _ = cv2.findContours(mascara, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
                for contorno in contornos:
                    if cv2.contourArea(contorno) > 500:
                        objetos_encontrados.append((cv2.contourArea(contorno), contorno, nome_cor))

            if len(objetos_encontrados) > 0:
                area_maior, contorno_maior, cor_detectada = max(objetos_encontrados, key=lambda item: item[0])
                forma_detectada = identificar_forma(contorno_maior)
                
                # --- 4. ATUALIZAR A VARI√ÅVEL GLOBAL QUANDO UM OBJETO √â DETECTADO ---
                texto_global_detectado = f"{forma_detectada} {cor_detectada}"
                
                (x, y, largura, altura) = cv2.boundingRect(contorno_maior)
                cv2.rectangle(quadro, (x, y), (x + largura, y + altura), (0, 255, 0), 2)
                cv2.putText(quadro, texto_global_detectado.capitalize(), (x, y - 10), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (0, 255, 0), 2)
            
            # --- 5. DESENHAR O BOT√ÉO EM CADA FRAME ---
            cv2.rectangle(quadro, botao_pos_inicial, botao_pos_final, (200, 200, 200), -1) # Fundo do bot√£o
            cv2.putText(quadro, "Falar", (botao_pos_inicial[0] + 50, botao_pos_inicial[1] + 35), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 0, 0), 2)
            # -------------------------------------------

            cv2.imshow(NOME_JANELA, quadro)

            # Captura a tecla pressionada (agora s√≥ para sair)
            tecla = cv2.waitKey(1) & 0xFF
            if tecla == ord('q'):
                break

        captura.release()
        cv2.destroyAllWindows()
      </pre>
    </div>
  </div>

  <div id="popup5" class="overlay">
    <div class="popup">
      <button class="fechar" onclick="fecharPopup('popup5')">Fechar</button>
      <h3>calibracao_camera.npz</h3>
      <pre>

        
      </pre>
    </div>
  </div>


          
    </div>
  </body>
</html>
