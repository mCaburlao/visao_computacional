<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Lab.04 || CV - 2025.2</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="../lab04.css">
    <link rel="stylesheet" href="../../../menu.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.1/css/all.min.css"
        integrity="sha512-+4zCK9k+qNFUR5X+cKL9EIR+ZOhtIloNl9GIKS57V1MyNsYpYcUrUeQc9vNfzsWfV28IaLL3i96P9sdNyeRssA=="
        crossorigin="anonymous" />
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link rel="stylesheet"
        href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Dancing+Script:wght@700&display=swap">
    <!-- Slick CSS no <head> -->
    <link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.css" />
    <link rel="stylesheet" type="text/css"
        href="https://cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick-theme.css" />

</head>

<!-- JQuery + Slick JS -->
<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/slick-carousel@1.8.1/slick/slick.min.js"></script>

<!-- Arquivo JS externo -->
<script src="../lab02.js"></script>

<body>
    <div class="container">
        <nav>
            <ul class="mcd-menu">
                <!-- <li>
                    <a href="">
                        <i class="fa fa-home"></i>
                        <div>
                            <strong>Home</strong>
                            <small>Incompleto</small>
                        </div>
                    </a>
                </li> -->
                <li>
                    <a href="../../../index.html">
                        <i class="fa fa-edit"></i>
                        <div>
                            <strong>Sobre nós</strong>
                            <small>Completo</small>
                        </div>
                    </a>
                </li>
                <li>
                    <a href="../../aulas.html" class="active">
                        <i class="fa fa-id-card"></i>
                        <div>
                            <strong>Aulas</strong>
                            <small>Incompleto</small>
                        </div>
                    </a>
                </li>
                <li>
                    <a href="../../../trabalho/trabalho.html">
                        <i class="fa fa-archive"></i>
                        <div>
                            <strong>Projeto</strong>
                            <small>Incompleto</small>
                        </div>
                    </a>
                </li>
            </ul>
        </nav>
    </div>
    <div class="principal">

        <button onclick="history.back()" class="btn-voltar">
            <i class="fas fa-arrow-left"></i>
        </button>

        <h1 class="titulo">Lab 04: Cálculo do Mapa de Disparidade</h1>
        <br />
        <p>&emsp; A geração do mapa de disparidade é uma das etapas mais importantes do processo de percepção de
            profundidade por meio de visão estéreo. Esse mapa representa, pixel a pixel, a diferença de posição de um
            mesmo
            ponto da cena entre as duas imagens capturadas pelas câmeras estéreo (esquerda e direita). Essa diferença,
            chamada
            de disparidade, está diretamente relacionada à distância do objeto até a câmera: quanto maior a disparidade,
            mais
            próximo o objeto está.</p>
        <br />
        <p>&emsp; Para realizar essa etapa, foi utilizado o algoritmo Block Matching (BM) do OpenCV, um dos métodos
            clássicos para correspondência estéreo. O algoritmo funciona comparando blocos de pixels entre as duas
            imagens,
            tentando encontrar, para cada pixel da imagem da esquerda, a melhor correspondência na imagem da direita,
            dentro
            de uma janela de busca. A posição com a melhor correspondência determina o valor da disparidade para aquele
            ponto.
        </p>
        <p>&emsp; O programa base utilizado para essa tarefa foi o disparity_params_gui.py, fornecido pelo repositório
            oficial do projeto. Esse script já possuía uma interface gráfica interativa, permitindo o ajuste dinâmico
            dos
            principais parâmetros do algoritmo BM. No entanto, foi necessário adaptá-lo para carregar corretamente os
            parâmetros de calibração estéreo gerados previamente e salvos no arquivo params_py.xml. Esse arquivo contém
            as
            informações intrínsecas e extrínsecas das câmeras, como matrizes de calibração, coeficientes de distorção e
            matrizes de retificação, que são essenciais para o alinhamento correto das imagens antes do cálculo de
            disparidade.
        </p>
        <pre><code class="language-python">
import numpy as np 
import cv2


# Check for left and right camera IDs
# These values can change depending on the system
CamL_id = 2 # Camera ID for left camera
CamR_id = 0 # Camera ID for right camera

CamL= cv2.VideoCapture(CamL_id)
CamR= cv2.VideoCapture(CamR_id)

# Reading the mapping values for stereo image rectification
cv_file = cv2.FileStorage("params_py.xml", cv2.FILE_STORAGE_READ)
Left_Stereo_Map_x = cv_file.getNode("Left_Stereo_Map_x").mat()
Left_Stereo_Map_y = cv_file.getNode("Left_Stereo_Map_y").mat()
Right_Stereo_Map_x = cv_file.getNode("Right_Stereo_Map_x").mat()
Right_Stereo_Map_y = cv_file.getNode("Right_Stereo_Map_y").mat()
cv_file.release()

def nothing(x):
    pass

cv2.namedWindow('disp',cv2.WINDOW_NORMAL)
cv2.resizeWindow('disp',600,600)

cv2.createTrackbar('numDisparities','disp',1,17,nothing)
cv2.createTrackbar('blockSize','disp',5,50,nothing)
cv2.createTrackbar('preFilterType','disp',1,1,nothing)
cv2.createTrackbar('preFilterSize','disp',2,25,nothing)
cv2.createTrackbar('preFilterCap','disp',5,62,nothing)
cv2.createTrackbar('textureThreshold','disp',10,100,nothing)
cv2.createTrackbar('uniquenessRatio','disp',15,100,nothing)
cv2.createTrackbar('speckleRange','disp',0,100,nothing)
cv2.createTrackbar('speckleWindowSize','disp',3,25,nothing)
cv2.createTrackbar('disp12MaxDiff','disp',5,25,nothing)
cv2.createTrackbar('minDisparity','disp',5,25,nothing)

# Creating an object of StereoBM algorithm
stereo = cv2.StereoBM_create()

while True:

	# Capturing and storing left and right camera images
	retL, imgL= CamL.read()
	retR, imgR= CamR.read()
	
	# Proceed only if the frames have been captured
	if retL and retR:
		imgR_gray = cv2.cvtColor(imgR,cv2.COLOR_BGR2GRAY)
		imgL_gray = cv2.cvtColor(imgL,cv2.COLOR_BGR2GRAY)

		# Applying stereo image rectification on the left image
		Left_nice= cv2.remap(imgL_gray,
							Left_Stereo_Map_x,
							Left_Stereo_Map_y,
							cv2.INTER_LANCZOS4,
							cv2.BORDER_CONSTANT,
							0)
		
		# Applying stereo image rectification on the right image
		Right_nice= cv2.remap(imgR_gray,
							Right_Stereo_Map_x,
							Right_Stereo_Map_y,
							cv2.INTER_LANCZOS4,
							cv2.BORDER_CONSTANT,
							0)

		# Updating the parameters based on the trackbar positions
		numDisparities = cv2.getTrackbarPos('numDisparities','disp')*16
		blockSize = cv2.getTrackbarPos('blockSize','disp')*2 + 5
		preFilterType = cv2.getTrackbarPos('preFilterType','disp')
		preFilterSize = cv2.getTrackbarPos('preFilterSize','disp')*2 + 5
		preFilterCap = cv2.getTrackbarPos('preFilterCap','disp')
		textureThreshold = cv2.getTrackbarPos('textureThreshold','disp')
		uniquenessRatio = cv2.getTrackbarPos('uniquenessRatio','disp')
		speckleRange = cv2.getTrackbarPos('speckleRange','disp')
		speckleWindowSize = cv2.getTrackbarPos('speckleWindowSize','disp')*2
		disp12MaxDiff = cv2.getTrackbarPos('disp12MaxDiff','disp')
		minDisparity = cv2.getTrackbarPos('minDisparity','disp')
		
		# Setting the updated parameters before computing disparity map
		stereo.setNumDisparities(numDisparities)
		stereo.setBlockSize(blockSize)
		stereo.setPreFilterType(preFilterType)
		stereo.setPreFilterSize(preFilterSize)
		stereo.setPreFilterCap(preFilterCap)
		stereo.setTextureThreshold(textureThreshold)
		stereo.setUniquenessRatio(uniquenessRatio)
		stereo.setSpeckleRange(speckleRange)
		stereo.setSpeckleWindowSize(speckleWindowSize)
		stereo.setDisp12MaxDiff(disp12MaxDiff)
		stereo.setMinDisparity(minDisparity)

		# Calculating disparity using the StereoBM algorithm
		disparity = stereo.compute(Left_nice,Right_nice)
		# NOTE: compute returns a 16bit signed single channel image,
		# CV_16S containing a disparity map scaled by 16. Hence it 
		# is essential to convert it to CV_32F and scale it down 16 times.

		# Converting to float32 
		disparity = disparity.astype(np.float32)

		# Scaling down the disparity values and normalizing them 
		disparity = (disparity/16.0 - minDisparity)/numDisparities

		# Displaying the disparity map
		cv2.imshow("disp",disparity)

		# Close window using esc key
		if cv2.waitKey(1) == 27:
			break
	
	else:
		CamL= cv2.VideoCapture(CamL_id)
		CamR= cv2.VideoCapture(CamR_id)

print("Saving depth estimation paraeters ......")

cv_file = cv2.FileStorage("depth_estmation_params_py.xml", cv2.FILE_STORAGE_WRITE)
cv_file.write("numDisparities",numDisparities)
cv_file.write("blockSize",blockSize)
cv_file.write("preFilterType",preFilterType)
cv_file.write("preFilterSize",preFilterSize)
cv_file.write("preFilterCap",preFilterCap)
cv_file.write("textureThreshold",textureThreshold)
cv_file.write("uniquenessRatio",uniquenessRatio)
cv_file.write("speckleRange",speckleRange)
cv_file.write("speckleWindowSize",speckleWindowSize)
cv_file.write("disp12MaxDiff",disp12MaxDiff)
cv_file.write("minDisparity",minDisparity)
cv_file.write("M",39.075)
cv_file.release()
    </code></pre>
        <br />
        <p>
            &emsp;Com o script adaptado, foram realizados diversos testes para ajustar os seguintes parâmetros:
        </p>
        <ul>
            <li><strong>numDisparities</strong>: número máximo de disparidades consideradas pelo algoritmo;</li>
            <li><strong>blockSize</strong>: tamanho da janela usada para comparar blocos entre as imagens;</li>
            <li><strong>preFilterCap</strong>: valor de normalização das imagens antes da correspondência;</li>
            <li><strong>uniquenessRatio</strong>: razão usada para garantir que a correspondência encontrada seja única;
            </li>
            <li><strong>textureThreshold</strong>: limiar para ignorar áreas com pouca textura;</li>
            <li><strong>speckleWindowSize</strong> e <strong>speckleRange</strong>: parâmetros para filtragem de ruído
                (“speckles”) no mapa gerado.</li>
        </ul>
        <br />
        <p>
            &emsp;Durante o processo de ajuste, observou-se que pequenas variações nesses parâmetros impactam
            significativamente a qualidade do mapa de disparidade. Parâmetros muito baixos produziam mapas com muito
            ruído e
            inconsistências, enquanto valores muito altos podiam suavizar excessivamente os detalhes, perdendo
            informação de
            profundidade. Portanto, o ajuste fino foi feito com base em observações visuais da cena e validação
            posterior nas
            medidas de profundidade.
        </p>
        <p>
            &emsp;Ao final da etapa, o mapa de disparidade foi gerado e foi salvo no arquivo
            <strong>depth_estimation_params_py.xml</strong>. Este arquivo armazena não apenas o mapa em si, mas também
            os
            parâmetros utilizados para gerá-lo, sendo essencial para as etapas seguintes de conversão em mapa de
            profundidade
            e para as medições de distância automatizadas.
        </p>
        <br />

</body>

</html>